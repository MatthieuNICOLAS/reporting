* Journal de bord
** Semaine du <2016-09-12 lun.> au <2016-09-16 ven.>
*** Done
- Faire un état de l'art des mécanismes d'authentification
  - Différences entre OAuth et OpenID
    - OAuth est un protocole d'*autorisation*
    - Il permet à un utilisateur de donner accès à certaines données/actions de son compte à un service tiers
      - Exemple avec Google +
        - Récupérer les informations du profil
        - Récupérer les informations des cercles d'amis de l'utilisateur
        - Envoyer des mails au nom de l'utilisateur
      - Exemple avec GitHub
        - Récupérer les informations du profil
        - Accéder aux repos de l'utilisateur
        - Faire des commits en son nom
    - Il ne s'agit cependant pas d'un protocole d'*authentification*
      - On peut supposer que si Google ou GitHub nous donne accès au compte de l'utilisateur, c'est car ce dernier s'est authentifié correctement
      - Mais rien n'empêche un site ayant obtenu un code (car l'utilisateur a donné l'autorisation à ce dernier) d'utiliser ce code pour usurper l'identité de l'utilisateur sur un autre site
    - OpenID lui est un protocole d'*authentification*
      - Il permet seulement de vérifier l'identité d'un utilisateur
      - Il ne permet pas d'accéder à des données de son compte autre que celles du profil
    - OpenID Connect est un protocole basé sur OAuth 2.0 qui ajoute une couche d'authentification au protocole
    - Sources
      - http://security.stackexchange.com/questions/44611/difference-between-oauth-openid-and-openid-connect-in-very-simple-term
      - https://oauth.net/2/
      - https://en.wikipedia.org/wiki/OpenID
      - http://openid.net/connect/
      - http://www.thread-safe.com/2012/01/problem-with-oauth-for-authentication.html
  - Libraries/Frameworks
    - Pour OAuth2: https://oauth.net/code/
    - Pour OpenID Connect: http://openid.net/developers/libraries/
*** Planned
** Semaine du <2016-09-19 lun.> au <2016-09-23 ven.>
*** Done
- Faire un état de l'art des mécanismes d'authentification
  - Réalisation des slides
    - Disponibles ici : https://github.com/MatthieuNICOLAS/authentication-systems-2016-09-20/
  - Ajout des nouvelles sources : 
    - [[https://pdfs.semanticscholar.org/3733/2607f7a7ac8284c514845957fd00583e5614.pdf][Different Ways to Authenticate Users with the Pros and Cons of each Method]]
      - Bonne définition de l'*Authentification*.
      - Parle de l'authentification à facteurs multiples :
        - Passwords
        - Smart cards
        - X509 certificate
        - Biometrics
      - Présente les avantages et inconvénients ainsi que les vulnérabilités de chacune.
    - [[http://stackoverflow.com/questions/663402/what-are-the-differences-between-ldap-and-active-directory][What are the differences between LDAP and Active Directory?]]
      - Donne les définitions de *Directory Service*, *Active Directory* et *Lightweight Directory Access Protocol*
    - [[https://www.neustar.biz/blog/what-is-single-sign-on-deployment-pros-cons][The Pros & Cons of Implementing Single Sign-On]]
      - Explique les différences entre *Full Sign-On*, *Reduced Sign-On* et *Federated Logins*
    - [[https://tools.ietf.org/html/rfc6749][RFC 6749 - The OAuth 2.0 Authorization Framework]]
      - Description du protocole OAuth 2.0
    - [[http://wiki.oauth.net/w/page/27249271/OAuth%202%20for%20Native%20Apps][OAuth 2 for Native Apps]]
    - [[https://tools.ietf.org/html/draft-ietf-oauth-native-apps-03][Authorization Flow for Native Apps Using App-Claimed URI Schemes]]
    - [[http://nat.sakimura.org/2012/01/20/openid-connect-nutshell/][OpenID Connect in a nutshell]]
    - [[http://wiki.openid.net/w/page/12995171/Introduction][OpenID explaination]]
    - [[https://en.wikipedia.org/wiki/OAuth#/media/File:OpenIDvs.Pseudo-AuthenticationusingOAuth.svg][OpenID Authentication vs Pseudo-Authentication using OAuth]]
    - [[https://www.owasp.org/index.php/Authentication_Cheat_Sheet][Authentication Cheat Sheet]]
- Finaliser les slides sur les mécanismes d'authentification et les envoyer à TVPaint
  - Ajout de références vers les articles lus/utilisés et pouvant s'avérer utiles pour leur compréhension
  - Création d'un thread sur le forum de TVPaint pour linker les slides et les inviter à poser leurs questions
- MUTE : Implémenter le bot de traduction
  - Problème avec la librairie *mute-client*
    - *mute-client* embarque *AceEditorAdapter*
    - Ce code JS suppose que *AceEditor* est dans le scope
    - Ce n'est pas le cas dans le bot
- PLM : Activer Blockly
  - Modification du code de *GitActor* pour gérer les langages de programmation visuels
    - Stocker le code généré par l'outil de programmation visuel
    - Mais aussi stocker le /code visuel/
      - Pour pouvoir regénérer l'espace de travail de l'apprenant à sa prochaine connexion
  - Modification du code de *PLMActor* pour gérer les langages de programmation visuels
    - Envoi à *GitActor* le /code visuel/
    - Lors de la récupération de la session de l'utilisateur, on ne récupère pas le code de l'élève
      - Puisqu'il s'agit du code généré par l'outil de programmation visuel
        - Par exemple du code Python dans le cas de Blockly
    - Il faut récupérer plutôt le /code visuel/ pour regénérer l'espace de travail
    - Pour le moment, on se contente de renvoyer un /code visuel/ vide
  - Activation de Blockly
    - Création d'une instance de *LangBlockly*
    - Ajout de celle-ci dans les langages de programmation supportés
  - Modification du code pour gérer les exercices ne supportant pas Blockly
    - Passage automatique au langage de programmation par défaut si le langage courant n'est pas supporté
    - Affichage d'un message d'avertissement lorsque l'utilisateur essaie de passer à un langage non-supporté par l'exo courant
  - Mise à jour des sérialisation JSON des exercices
*** Planned
**** DONE Faire un état de l'art des mécanismes d'authentification
- Étudier les différents mécanismes existants et comment ils interagissent entre eux
  - SAML
  - SOAP
  - OAuth
  - OpenID
  - LDAP

**** DONE Finaliser les slides sur les mécanismes d'authentification et les envoyer à TVPaint
- J'ai noté quelques sources qui pourraient s'avérer utiles pour TVPaint
- Les ajouter aux slides
- Envoyer les slides à TVPaint
**** DONE PLM : Activer Blockly
- [[http://www.pentilanero.com/][Pentila]] m'a recontacté à propos de PLM
- Ils sont en train de travailler sur PLM pour voir comment ajouter de nouveaux exercices fonctionnant avec Blockly
- Sauf que j'ai désactivé Blockly lors du refactoring
- Activer de nouveau Blockly
- Vérifier son bon fonctionnement
** Semaine du <2016-09-26 lun.> au <2016-09-30 ven.>
*** Done
- TVPaint : Réviser les notions autour du *Business Process* et des *Workflows*
  - L'activité /Call/ est-elle utilisable ou à éviter ?
  - Que signifie la notion d'entité lorsqu'on parle de /Choreography/ ?
    - Similaire à la notion de /Pool/ ?
  - Différences entre /Choreography/ et /Collaboration/
    - Pourquoi utiliser l'un et pas l'autre ?
    - Formalisme différent, et la /Choreography/ fonctionne par le biais d'envoi de messages
  - Une /Choreography/ est-elle forcément entre 2 entités ?
    - Il n'y a jamais eu le besoin de définir une choréographie entre 3+ entités ?
    - Non, une /Choreography/ peut avoir lieu entre 3+ entités
- MUTE : Implémenter le bot de traduction
  - Ajout de la classe *TranslatorBot*
    - Instancie un *Bot* pour être pouvoir être ajouté au réseau
    - Instancie un *Coordinator* lors de son ajout au réseau
    - Écoute l'évènement /update/ du *Coordinator* pour déclencher l'opération de traduction
    - Écoute l'évènement /operations/ du *Coordinator* pour transmettre les opérations générées localement aux pairs 
    - Lors d'un /update/, parcourt le document pour trouver le texte à traduire
      - Le texte à traduire est délimité par les balises suivantes
        - /tl <langue source> <langue destination>
        - end/
    - Demande à *YandexTranslateService* de traduire le texte
    - Remplace le texte à traduire + balises par le résultat renvoyé par *YandexTranslateService*
  - Malheureusement, ce n'était pas le comportement attendu
    - On souhaite insérer une balise dans le document
    - Le bot doit
      - Récupérer le texte précédent cette balise
      - Le traduire
      - L'insérer après la balise
  - Implémentation de ce comportement
    - Ajout de *RealTimeTranslator*
    - Détecte le tag de l'utilisateur /rt
    - Le remplace par son propre tag
      - Cela lui permet de récupérer l'ID LogootSplit de ce tag
      - Cet ID est ensuite utilisé pour récupérer l'index du tag dans le document
    - Traduit le texte
      - Utilise /diff/ pour comparer l'ancienne traduction et la nouvelle
      - Permet de seulement mettre à jour les parties de la traduction concernées par les modifications du texte initial
- PLM : Corriger l'exécution du code de l'apprenant en Python
  - Le bug rencontré par Cédric n'est pas reproductible dans mon environnement de dev
  - Par contre, dans un container Docker basé sur l'image de webPLM, je rencontre une erreur lié à *JRuby*
    - Je n'inclus pas le jar de *JRuby* dans *PLM-engine*
  - Ajout de *JRuby* dans *PLM-engine*
    - Résous l'erreur lié à *JRuby*
  - Je rencontre dorénavant l'erreur reportée par Cédric
    - Cette erreur semble liée à la version de *Jython* utilisée
  - Mise à jour de *Jython*
  - Le plus troublant est que les juges arrivaient à exécuter du code Python
    - *JRuby* était correctement inclus dans le jar de *PLM* fourni aux juges
    - Mais ils auraient dû déclencher l'erreur liée à la version de *Jython*
*** Planned
**** DONE PLM : Corriger l'exécution du code de l'apprenant en Python
- Cédric de Pentila m'a contacté à propos des problèmes qu'il rencontre pour exécuter du code Python
- Il rencontre l'erreur suivante en essayant d'exécuter son programme Python
#+BEGIN_SRC
java.lang.NullPointerException
  at org.python.core.Py.recursiveIsInstance(Py.java:1861)
  at org.python.core.Py.isInstance(Py.java:1828)
  at org.python.core.__builtin__.isinstance(__builtin__.java:725)
  at org.python.core.Py.displayException(Py.java:1009)
  at org.python.core.PyException.printStackTrace(PyException.java:79)
  at org.python.core.PyException.toString(PyException.java:98)
  at java.lang.Throwable.<init>(Throwable.java:311)
  at java.lang.Exception.<init>(Exception.java:102)
  at javax.script.ScriptException.<init>(ScriptException.java:65)
  at org.python.jsr223.PyScriptEngine.scriptException(PyScriptEngine.java:192)
  at org.python.jsr223.PyScriptEngine.eval(PyScriptEngine.java:43)
  at org.python.jsr223.PyScriptEngine.eval(PyScriptEngine.java:33)
  at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:264)
  at plm.core.lang.ScriptingLanguage.runEntity(Unknown Source)
  at plm.core.model.lesson.ExerciseRunner$3.run(Unknown Source)
  at java.lang.Thread.run(Thread.java:745)
#+END_SRC
- Trouver l'origine de cette erreur et la résoudre
**** DONE MUTE : Implémenter le bot de traduction
- Dans le cadre de l'évaluation de l'équipe du 13 octobre, une démo de [[https://github.com/coast-team/mute-demo][MUTE]] est prévue
- L'idée est de mettre en avant la fonctionnalité des bots à l'aide d'un bot qui traduirait pour nous le document
- Le code du bot est disponible ici : https://github.com/coast-team/mute-bot-eve
- Analyser le document pour détecter les parties du document à traduire
- Interroger *Yandex* pour traduire le texte
- Remplacer le texte par sa traduction
**** DONE TVPaint : Réviser les notions autour du *Business Process* et des *Workflows*
- Nécessaire pour pouvoir mieux appréhender la tâche consistant à définir un process pour représenter le déroulement de la réalisation d'un film avec TVPaint
- Sources à utiliser:
  - http://webloria.loria.fr/~charoy/uploads/Main/BPM2pp.pdf
  - http://www.workflowpatterns.com/
  - http://fr.bonitasoft.com/ressources
** Semaine du <2016-10-03 lun.> au <2016-10-07 ven.>
*** Done
- TVPaint : Définir le business process correspondant à la réalisation d'un film
  - Quelques questions sont apparus au cours de la réalisation
    - Est-ce qu'il y a une phase de validation
      - Après la réalisation du storyboard
      - Après la réalisation de l'animatique
    - Est-ce que l'animatique et le storyboard se font de façon séquentielle ou parallèle?
    - Est-ce que l'animatique "modifie" le storyboard ou produit une nouvelle donnée?
    - Qui s'occupe de l'élaboration du layout du shot?
    - Est-ce que l'élaboration du layout du shot inclus le typage de chaque clip?
- PLM : Release d'une nouvelle version de PLM
  - Transfert des commits modifiant l'UI dans une branche distincte
  - Activation des leçons sur la récursivité
  - Correction du nom des fichiers de consignes pour l'exercice *Occurrences*
  - Correction de l'entité Java de l'exercice *IsMember*
  - Augmentation de la limite de temps d'exécution de PLM-judge
  - Release de webPLM:2.1.1 et de PLM-judge:2.1.1
- PLM : Corriger l'exécution de code Java
  - L'erreur ne semble se produire qu'en exécutant du code via les juges
  - L'erreur est liée à 2 morceaux de code
    - [[https://github.com/BuggleInc/PLM/blob/master/src/plm/core/lang/ProgrammingLanguage.java#L131-L139][ProgrammingLanguage.getProgrammingLanguage()]]
    - [[https://github.com/BuggleInc/PLM/blob/master/src/plm/core/model/lesson/BlankExercise.java#L26-L27][BlankExercise()]]
  - Lorsqu'on désérialise un exercice, on regénère les instances de *SourceFile* pour chaque langage de programmation
  - Ainsi, on instancie le *SourceFile* et on le stocke dans une *Map* en l'associant au *ProgrammingLanguage* retourné par /getProgrammingLanguage()/
  - Sauf que la fonction /getProgrammingLanguage()/ retourne une valeur par défaut s'il ne trouve pas de *ProgrammingLanguage* correspondant à la chaîne passée en paramètre
  - Du coup, lorsqu'on rencontre un *ProgrammingLanguage* inconnu, on remplace le *SourceFile* associé au langage par défaut par celui nouvellement créé
  - Ici, c'est *Blockly* qui n'est pas supporté par *PLM-judge* et qui pose problème
  - Ajout du support de *Blockly*
  - Ouverture d'une issue pour garder une trace du problème : https://github.com/BuggleInc/PLM/issues/477
- PLM : Corriger l'exercice Polygon360
  - L'erreur ne provient pas de la sérialisation JSON stockée
    - Supprimer la sérialisation de l'exercice et l'instancier depuis les sources ne corrige pas le problème
  - Le plus troublant est l'affichage du monde objectif
  - Une partie du polygone semble manquer dans le monde objectif
    #+CAPTION: Partie manquante du polygone
    #+NAME:   fig:polygon360-missingline.png
    [[file:img/polygon360-missingline.png]]
  - Représentation des lignes indiquées dans le message d'erreur
    #+CAPTION: Lignes posant problème
    #+NAME:   fig:polygon360-showlines.png
    [[file:img/polygon360-showlines.png]]
    - La ligne bleue correspond à la ligne manquante dans le monde objectif
    - La ligne rouge correspond à la ligne manquante dans le monde courant
  - On arrive à la même conclusion en listant les *Shapes* présentes dans chacun des mondes
    #+BEGIN_SRC
    // Lines of the current world with x1 or x2 > 262
    CurrentWorld: Line (x262,263 y127,117 / x263,445 y135,028 / black)
    CurrentWorld: Line (x262,923 y164,938 / x263,968 y154,996 / black)
    CurrentWorld: Line (x263,445 y135,028 / x264,177 y149,000 / black)

    // Lines of the answer world with x1 or x2 > 262
    AnswerWorld: Line (x262,263 y127,117 / x263,445 y135,028 / black)
    AnswerWorld: Line (x262,923 y164,938 / x263,968 y154,996 / black)
    AnswerWorld: Line (x263,968 y154,996 / x264,177 y149,000 / black)
    #+END_SRC
*** Planned
**** DONE PLM : Release une nouvelle version de PLM
- Pour le module de TOP à TN, les étudiants vont travailler sur PLM
- Les enseignements de ce module porte notamment sur la récursivité
- Les leçons correspondantes ne sont pas activées dans la version actuelle de la PLM
- Les activer et déployer la nouvelle version
**** DONE PLM : Corriger l'exécution de code Java
- Depuis la mise à jour, l'exécution du code Java génère une erreur
  #+BEGIN_SRC
  Compilation error: Environment.java:0:class, interface, or enum expected
  #+END_SRC
- Trouver l'origine de l'erreur et la corriger
** Semaine du <2016-10-10 lun.> au <2016-10-14 ven.>
*** Done
- TVPaint : Définir le business process correspondant à la réalisation d'un film
  - Ajout des phases de vérification pour
    - Le storyboard
    - L'animation
  - Ajout des données des formulaires
    - Création du film
    - Phases de vérification
  - Difficultés rencontrées
    - Bloque sur l'instanciation d'un *Storyboard* et d'une *Animation* à partir des fichiers soumis par les utilisateurs
    - Aussi des difficultés sur la multi-instanciation du process pour gérer un shot
      - On souhaite générer une instance du process pour chaque shot
      - La liste des shots se trouvent dans l'instance de *Film*
      - Mais je n'arrive pas accéder à la variable de process /movie/
      - Pour l'instant, je passe par une autre variable de process /shots/
    - Je n'arrive plus non plus à créer un type /enum/ avec Bonita Soft
  - Quelques questions sur le workflow
    - Que se passe-t-il/que fait-on si un shot ne passe pas la dernière étape de validation?
      - L'étape de validation concernée se trouve après l'activité /compositing/
      - Est-ce qu'elle ne sert qu'à valider cette activité ou elle sert à valider l'ensemble des clips?
  - Quelques questions sur les modèles de données
    - À quoi correspond le modèle de données *Scene* ?
    - Que contient le modèle de données *Animation* ?
- MUTE : Préparer la démo pour l'évaluation INRIA
  - Philippe a installé les différents composants de la démo sur les Raspberries et configuré les interfaces réseaux
  - Scénario :
    - Introduction
      - Au départ, seul MUTE est déployé
      - Le bot est démarré, mais il n'est pas encore relié au réseau
      - Gérald (qui projetera son écran) se connectera à un document pré-existant
      - Collaboration rapide pour montrer l'aspect temps réel
    - Ajout du bot
      - On le connecte au réseau
      - On l'invite dans l'édition collaborative
      - On l'active
      - On observe qu'il traduit le texte déjà existant et met ensuite à jour en temps réel (mais avec délai) la traduction
    - Sans serveur
      - On débranche la Raspberry correspondant au serveur
      - On observe que la collaboration fonctionne toujours
  - Texte à taper :
    #+BEGIN_QUOTE
    Pourquoi je veux vous réunir : pour vous ou pour moi?
    Evidemment pour moi, cela résoudrait tout pour moi ; j'en ai décidé ainsi depuis longtemps...
    On m'a raconté que votre soeur Adélaïde avait dit de mon portrait qu'avec une beauté pareille on pouvait bouleverser le monde.
    Mais j'ai renoncé au monde ; cela vous paraît drôle venant de moi, alors que vous me rencontrez couverte de bijoux et de dentelles en compagnie d'ivrognes et de scélérats?
    Ne faites pas attention à cela, je n'existe presque plus, et je le sais ; Dieu sait ce qui habite en moi à ma place.
    -- Dostoïevski dans son roman "Idiot"
    #+END_QUOTE
  - Répétition de la démo
- PLM : Release une image de NGINX pour le mode développement
  - Ajout d'un répertoire pour indiquer que la config actuelle est celle pour TELECOM Nancy
  - Modification de la configuration pour ajouter le reverse-proxy pour la queue de message
  - Ajout d'une autre configuration pour le mode développement
  - Génération des images Docker correspondantes
*** Planned
**** DONE PLM : Release une image de NGINX pour le mode développement
- Depuis le rework du protocole de communication avec les juges, NGINX est utilisé comme reverse-proxy pour accéder à la queue de message
  - Le port 15674 (utilisé par STOMP) n'est pas ouvert sur la machine de TN
  - NGINX permet d'accéder à ce port via un reverse-proxy
- Ceci empêche le docker-compose pour le mode développement de fonctionner correctement
  - Il ne met pas en place de NGINX
- Faire une image Docker de NGINX pour le développement
- Mettre à jour le docker-compose correspondant
**** DONE MUTE : Préparer la démo pour l'évaluation INRIA
- Tester l'environnement de la démo
- Établir le scénario de la démo
- Trouver un texte à taper et se le répartir
** Semaine du <2016-10-17 lun.> au <2016-10-21 ven.>
*** Done
- TVPaint : Définir le business process correspondant à la réalisation d'un film
  - De nouvelles questions sur le workflow
    - Est-ce que l'activité "Assignation outils/images" peut être entièrement automatisée ou pas?
- MUTE : Faire la roadmap du projet
  - La liste des tâches est disponible sur [[https://app.asana.com/][Asana]]
  - Définition des différentes étapes
    - v1: MUTE--
    - v2: Notepad equivalent
    - v3: Fourre-tout
  - Choix des technos
    - Angular 2
    - Angular Matérial 2
    - Ava
    - TSLint
*** Planned
**** DONE MUTE : Faire la roadmap du projet
- Pour répondre au besoin d'INRIA
- Lister les tâches à effectuer
- Les attribuer aux différentes étapes/versions du projet
- Établir le coût de chacune des tâches
**** DONE MUTE : Se former aux technologies choisies
- Lire [[https://books.ninja-squad.com/angular2][Become A Ninja With Angular 2]] et [[https://www.gitbook.com/book/basarat/typescript/details][TypeScript Deep Dive]]
** Semaines du <2016-11-14 lun.> au <2016-11-25 ven.>
*** Done
- MUTE : Développement de la nouvelle version de MUTE
  - Ajout de l'éditeur de texte *CodeMirror*
  - Création du modèle de données *LogootSRopes* du document
  - Détection des modifications de l'utilisateur et génération des *TextOperations* correspondantes
    - *TextInsert* et *TextDelete*
  - Mise à jour du modèle à partir de ces opérations textes
  - Envoi des *LogootSOperations* correspondantes aux modifications aux collaborateurs
  - Réception et ré-instantiation des *LogootSOperations*
  - Mise à jour du modèle à partir des opérations *LogootSplit*
  - Mise à jour de la vue du document
  - Passage à la nouvelle version de /Mute-structs/
  - Correction de bugs liées à la nouvelle version de /Mute-structs/
    - Suppression d'une boucle infinie dans la recherche d'un noeud
    - Correction des assertions effectuées lors des rotations
    - Correction des expressions permettant d'indiquer si l'on peut /append/ ou /prepend/ du texte à un bloc
** Semaine du <2016-11-28 lun.> au <2016-12-02 ven.>
*** Done
- TVPaint : Étudier comment collaborer dans un projet réalisé avec BonitaSoft
  - D'après [[http://community.bonitasoft.com/questions-and-answers/does-bonita-support-git-repository][ce topic]] et [[http://documentation.bonitasoft.com/6.x-7.2/workspaces-and-repositories-1][cette doc]], on ne peut pas partager un projet dans *Bonita* avec la version /Community/
  - La fonctionnalité est ajoutée dans la version /Subscription/
  - La doc ne semble disponible que pour SVN par contre
  - Et il manque les tarifs sur le site de *Bonita*, il faut prendre contact avec eux pour les obtenir
- MUTE : Développement du bot de stockage
  - Projet disponible [[https://github.com/coast-team/mute-bot-storage][ici]]
*** Planned
**** DONE TVPaint : Envoyer le travail effectué
**** DONE TVPaint : Étudier comment collaborer dans un projet réalisé avec BonitaSoft
- Voir si on peut partager avec Git
**** DONE MUTE : Développement du bot de stockage
** Semaine du <2016-12-05 lun.> au <2016-12-09 ven.>
*** Done
- MUTE : Lire l'article sur les barrières causales
  - Happened before relation
    - a -> b if a and b are events in the same process and a occured before b
    - a -> b if a is the event of sending a message M in a process and b is the event of delivery of the same message to another process
    - if a -> b and b -> c then a -> c
    - if a -/> b and b -/> a then a and b are said to be concurrent and represented as a || b
  - Reception != Delivery
    - Réception du message par le protocole de causal ordering
    - Livraison du message par le protocole de causal ordering à l'application
  - Destination set
    - Si on reçoit un message M2 ayant pour dépendance M1.
    - Si on a pas reçu M1 car on ne fait pas parti de son destination set, alors on peut le retirer de la liste des dépendances et délivrer M2.
  - Matrice Delivered
    - En local stocke et tient à jour matrice NxN Delivered tel que
      - Soit i le process courant, j et k 2 autres processes
      - Delivered(i)[j, k] = x indique que tous les messages de Pj à destination de Pk ayant une clock <= x ont été délivrés
	- Delivered(i) indique la matrice Delivered du process i
  - Vecteur CB
    - En local, maintien un vecteur CB de taille N de telle manière que si (k,x) appartiennent à CB(i)[j], cela implique que le prochain message de Pi à Pj devra être délivré uniquement après avoir reçu le Xième de Pk.
    - CB(i) = { j: { (process_id, counter), ... }, ... }
*** Planned
**** DONE MUTE : Lire l'article sur les barrières causales
- Maintenant que le bot de stockage est implémenté, on rencontre un problème lors de la synchronisation
- Si un utilisateur possède une version plus récente du document que le bot de stockage, celle-ci va se faire écraser lors de la synchronisation
- Alors qu'avec *LogootSplit*, on pourrait juste déterminer les opérations manquantes et synchroniser proprement les documents
- Dans un 1er temps on va implémenter un vecteur d'état pour déterminer les opérations manquantes
- Mais à terme, on pourra le remplacer par une barrière causale (ou mieux) pour optimiser le processus
- Se renseigner sur les barrières causales
** Semaine du <2016-12-12 lun.> au <2016-12-16 ven.>
*** Done
- MUTE : Refactorer *DocService*
  - Gestion des messages spécifiques à ce service dans *DocService*
    - Réception des messages
    - Sérialisation/Désérialisation des objets de /mute-structs/
  - Remplacement des instances de *Subject* par des couples *Observable*/*Observer*
    - Le but de *Subject* a l'air d'émettre une valeur, et non pas une suite d'évènements
      - *AsyncSubject* peut posséder plusieurs valeurs au cours du temps, mais celle-ci n'est émise seulement qu'à la complétion du /stream/
      - *BehaviorSubject* permet d'émettre plusieurs valeurs au cours du temps, mais il a besoin d'une valeur initiale et garde en mémoire la dernière valeur émise
      - *ReplaySubject* permet d'émettre plusieurs valeurs au cours du temps, mais il rejoue l'historique des valeurs à chaque abonné
    - C'est le couple *Observable*/*Observer* qui semble le plus indiqué dans ce cas
      - Il permet d'émettre plusieurs valeurs au cours du temps
      - Aucune valeur n'est nécessaire à sa création
      - Si on s'y abonne "en retard", on ne recevra que les prochaines valeurs émises
- MUTE : Ajouter *EditorService*
  - Ajout de *EditorService*
  - Modification de *DocService* pour lire les opérations locales à partir du stream
  - Modification de *EditorComponent* pour émettre les opérations via *EditorService*
- MUTE : Nettoyer les streams
  - À la destruction de *EditorComponent*, le stream /operationStream/ n'est pas automatiquement détruit.
  - Désabonnement aux streams à la destruction de *EditorComponent*
  - Ajout d'une méthode /clean()/ à *DocService* pour déclencher le désabonnement aux streams
  - Appel de /DocService.clean()/ à la destruction de *DocComponent*
- MUTE : Trouver l'origine du bug empêchant d'envoyer les opérations locales
  - Le problème provient plus exactement de la sérialisation de l'opération *LogootSAdd* ou *LogootSDel*
  - Maintenant qu'on utilise la version corrigée de /mute-structs/, j'ai mis à jour la définition du message *Identifier* dans /protobuf/
  - Au lieu d'envoyer une liste de /double/, j'envoie désormais une liste de /int32/
  - Cependant, le /replicaNumber/ fourni par /sigver/ est potentiellement un /double/
    - Voir https://github.com/coast-team/sigver/blob/master/src/sigver.js#L4 et https://github.com/coast-team/sigver/blob/master/src/sigver.js#L130
  - Notification du problème @Philippe
*** Planned
**** DONE MUTE : Refactorer *DocService*
- Actuellement, une partie de la logique de *DocService* se trouve dans *NetworkService*
- La déplacer dans *DocService*
- En profiter pour nettoyer le code
**** DONE MUTE : Ajouter *EditorService*
- Actuellement, *EditorComponent* interagit avec *DocService* pour lui fournir les opérations locales
  - Il expose son stream à *DocService* qui s'y abonne
- Cependant, lorsque *EditorComponent* est détruit (lorsque l'utilisateur retourne sur la liste des documents), *DocService* écoute toujours le stream des opérations locales
- Déplacer le stream des opérations locales dans un service *EditorService*
- Modifier *EditorComponent* pour qu'il émette les opérations par le biais de *EditorService*
**** DONE MUTE : Nettoyer les streams
- Actuellement, les différents *Services* et *Components* communiquent par le biais de /streams/
- Cependant, ceux-ci ne sont pas nettoyés notamment à la destruction des *Components*
  - Ceci semble provoquer des erreurs lors de la détection des changements puisqu'on essaie de mettre à jour vues qui ont été détruites
  - Et il s'agit bien évidemment d'une fuite mémoire
- Se désabonner des streams à la destruction des *Components*
- Se désabonner des streams à la destructions des *Services*
**** DONE MUTE : Trouver l'origine du bug empêchant d'envoyer les opérations locales
- De temps en temps, l'éditeur plante après la génération de la 1ère opération locale
- Cependant aucune erreur n'est générée
- Ce bug semble lié à l'envoi de l'opération aux autres pairs
  - Mais ce bug se déclenche même lorsqu'on édite le document seul
- Trouver l'origine de ce bug
** Semaine du <2017-01-03 mar.> au <2017-01-06 ven.>
*** Done
- MUTE : Ajouter le stockage au sein du navigateur du document
  - Plusieurs librairies sont disponibles pour utiliser une base de données au sein du navigateur
    - [[https://pouchdb.com/][PouchDB]]
      - Semble porté par sa communauté
      - Celle-ci est importante (<2017-01-03 mar.>: 8022 stars, 236 contributeurs)
    - [[https://localforage.github.io/localForage/][localForage]]
      - Porté par *Mozilla*
      - Dispose d'une communauté importante (<2017-01-03 mar.>: 7103 stars)
    - [[http://jio.readthedocs.io/en/latest/][jIO]]
      - Porté par *Nexedi*
      - Dispose de connecteurs pour stocker les données sur un service distant
  - Ces librairies reposent principalement sur /IndexedDB/, mais possèdent un mécanisme de fallback sur /WebSQL/ ou même /LocalStorage/
  - Elles proposent toutes les 3 une syntaxe reposant sur les /Promises/ ou les /callbacks/
  - Pour le moment, utilise *jIO*
  - Ajout du service *StorageService*
    - Instancie une base de données
    - Dispose d'une méthode /put()/ pour enregistrer un objet
    - Dispose d'une méthode /get()/ pour récupérer un objet
  - Modification de *DocService*
    - Lorsque le document est mis à jour, utilise *StorageService* pour stocker cette version du document
    - Lorsqu'on crée une session de collaboration, initialise le document à partir de sa version stockée si possible
- TVPaint : Étudier la gestion des ressources dans BonitaSoft
  - Pour gérer les organisations, groupes, rôles et utilisateurs, il faut passer par *BPM Studio*
    - Organization > Manage
    - Un utilisateur appartient à un groupe ou plusieurs groupes d'une organisation et possède un rôle dans chacun de ces groupes
  - Attribuer les tâches (/actor mapping/)
    - Dans l'onglet *Actors* du workflow, on peut créer et supprimer les différents filtres utilisés pour faire du /actor mapping/
    - C'est ensuite dans *Configuration* que l'on peut ajouter un comportement aux filtres
      - Possibilité de filtrer par groupe, rôle ou appartenance
      - Possibilité de définir un ensemble d'utilisateurs spécifiques
- TVPaint : Étudier comment interagir avec BonitaSoft par API
  - S'authentifier
    - POST http://localhost:8728/bonita/loginservice
    - Paramètres:
      - /username/
      - /password/
      - /redirect/: un booléen indiquant si on souhaite être dirigé après l'exécution de la requête
	- /redirectURL/ si /redirect/ est égal à /true/
    - Exemple:
      - POST http://localhost:8728/bonita/loginservice?username=walter.bates&password=1234&redirect=true
    - Réponse:
      - Le cookie obtenu dans la réponse est l'élément important qui permettra d'authentifier les requêtes suivantes
  - Récupérer l'identifiant de l'utilisateur
    - GET http://localhost:8728/bonita/API/identity/user
    - Paramètres
      - /f/: le champ avec lequel on souhaite filtrer
    - Exemple:
      - GET http://localhost:8728/bonita/API/identity/user?f=userName=walter.bates
    - Réponse:
      #+BEGIN_SRC
[
  {
    "firstname": "Walter",
    "icon": "icons/default/icon_user.png",
    "creation_date": "2016-10-03 10:58:50.106",
    "userName": "walter.bates",
    "title": "Mr",
    "created_by_user_id": "-1",
    "enabled": "true",
    "lastname": "Bates",
    "last_connection": "2017-01-05 11:42:22.132",
    "password": "",
    "manager_id": "3",
    "id": "4",
    "job_title": "Human resources benefits",
    "last_update_date": "2016-10-03 10:58:50.106"
  }
]
      #+END_SRC
  - Récupérer les tâches disponibles ou assignées à l'utilisateur
    - GET http://localhost:8728/bonita/API/bpm/humanTask
    - Paramètres:
      - /f/: le champ avec lequel on souhaite filtrer
    - Exemple:
      - GET http://localhost:8728/bonita/API/bpm/humanTask?f=assigned_id=4
    - Réponse:
      #+BEGIN_SRC
[
  {
    "displayDescription": "",
    "executedBy": "0",
    "rootContainerId": "3002",
    "assigned_date": "2017-01-05 13:17:45.454",
    "displayName": "Create movie project",
    "executedBySubstitute": "0",
    "dueDate": "2017-01-05 12:25:15.246",
    "description": "",
    "type": "USER_TASK",
    "priority": "normal",
    "actorId": "315",
    "processId": "5578352443955206281",
    "caseId": "3002",
    "name": "Create movie project",
    "reached_state_date": "2017-01-05 11:25:15.251",
    "rootCaseId": "3002",
    "id": "60004",
    "state": "ready",
    "parentCaseId": "3002",
    "last_update_date": "2017-01-05 11:25:15.251",
    "assigned_id": "4"
  }
]
      #+END_SRC      
    - Autre exemple:
      - GET http://localhost:8728/bonita/API/bpm/humanTask?state=waiting
    - Réponse:
      #+BEGIN_SRC
[
  {
    "displayDescription": "",
    "executedBy": "0",
    "rootContainerId": "3013",
    "assigned_date": "",
    "displayName": "Submit storyboard",
    "executedBySubstitute": "0",
    "dueDate": "2017-01-05 18:06:12.223",
    "description": "",
    "type": "USER_TASK",
    "priority": "normal",
    "actorId": "318",
    "processId": "5720704175050565481",
    "caseId": "3013",
    "name": "Submit storyboard",
    "reached_state_date": "2017-01-05 17:06:12.228",
    "rootCaseId": "3013",
    "id": "60038",
    "state": "ready",
    "parentCaseId": "3013",
    "last_update_date": "2017-01-05 17:06:12.228",
    "assigned_id": ""
  }
]
      #+END_SRC
  - Assigner une tâche
    - PUT http://localhost:8728/bonita/API/bpm/humanTask/:humanTaskID
    - Exemple:
      - PUT http://localhost:8728/bonita/API/bpm/humanTask/60038
        #+BEGIN_SRC
{
  "assigned_id":"4" 
}
        #+END_SRC
    - Réponse:
      - Réponse vide, juste le status *200* témoigne du bon fonctionnement de la requête
  - Effectuer une tâche
    - POST http://localhost:8728/bonita/API/bpm/userTask/:userTaskID/execution
    - Paramètres:
      - Dans l'URL
	- /userTaskID/: l'identifiant de la tâche que l'on exécute
      - Dans le corps de la requête
	- Les éléments du formulaire si nécessaire
    - Exemple:
      - POST http://localhost:8728/bonita/API/bpm/userTask/60037/execution
        #+BEGIN_SRC
{
  "name":"Scott Pilgrim 2",
  "width":1920,
  "height":1080,
  "framerate":24
}
	#+END_SRC
    - Réponse:
      - Réponse vide, juste le status *204* témoigne du bon fonctionnement de la requête
- TVPaint : Définir le business process correspondant à la réalisation d'un film
  - Présentation du business process lors de la réunion du <2017-01-06 ven.>
  - Reste à développer la tâche /compositing/
- MUTE : Ajouter la gestion des documents stockées en local
  - Ajout d'un service *StorageManagerService*
    - Garde une liste des services de stockage
    - Expose une référence vers le service de stockage courant
  - Ajout d'une classe abstraite *AbstractStorageService*
    - S'enregistre auprès de *StorageManagerService*
    - Expose deux fonctions:
      - /isReachable(): Promise<boolean>/
      - /getDocuments(): Promise<any>/
  - Modification de *BotStorageService* pour hériter de *AbstractStorageService*
  - Ajout du component *StorageComponent*
    - Possède en paramètre un *AbstractStorageService*
    - Vérifie si le service de stockage est disponible
    - Permet d'accéder à la liste de ses documents si c'est le cas
    - Se désactive sinon
  - Modification de *NavComponent*
    - Récupère dorénavant la liste des services de stockage à l'aide de *StorageManagerService*
    - Instancie un *StorageComponent* pour chacun d'entre eux
  - Modification de *DocsComponent*
    - Récupère dorénavant la liste des documents à l'aide de *StorageManagerService*
    - Reste à voir comment uniformiser le comportement des différents services de stockage
      - Récupération du document
      - Sauvegarde
*** Planned
**** DONE MUTE : Ajouter le stockage au sein du navigateur du document
**** DONE TVPaint : Étudier la gestion des ressources dans BonitaSoft
- Voir pour générer des rôles
- Voir pour générer des acteurs
- Voir comment attribuer les tâches
**** DONE TVPaint : Étudier comment interagir avec BonitaSoft par API
- Voir comment spécifier le début et la fin d'une tâche par API
**** DONE TVPaint : Définir le business process correspondant à la réalisation d'un film
- Le process a été décrit sommairement dans l'image suivante
  #+CAPTION: Réalisation d'un film
  #+NAME:   fig:WorkflowExample2.png
  [[file:img/WorkflowExample2.png]]
- Le réaliser sous *Bonita Studio*
  - Réfléchir aux données nécessaires
  - Voir comment représenter la réalisation des shots et des clips
** Semaine du <2017-01-09 lun.> au <2017-01-13 ven.>
*** Done
- RH : Durée maximale de CDDs à Inria
  - J'ai vu avec le service RH concernant la durée maximale que je peux passer en CDD à Inria
  - Elle est de 5 ans et 11 mois
  - Par contre, les thèses sont sous un autre régime
  - Je peux donc effectuer une thèse auprès Inria après mon contrat
- MUTE : Ajouter la gestion des documents stockées en local
  - Renommage de *StorageService* en *LocalStorageService*
  - Modification de *StorageManagerService*
    - Injecte *LocalStorageService* et *BotStorageService* dans son constructeur
    - Les enregistre lui-même dans sa liste des services de stockage
    - Sinon, tant que ces services ne sont pas injectés par ailleurs, ils ne sont pas instanciés et enregistrés
  - Modification de *LocalStorageService*
    - Ajout de /getDocuments()/ pour renvoyer la liste des documents stockés en local
  - Modification de *NetworkService*
    - Ajout de la méthode /cleanWebChannel()/
      - Auparavant effectué au cours du /join()/
      - Séparation de ces 2 méthodes
  - Modification de *DocComponent*
    - On avait un problème lorsqu'on passait d'un document à l'autre
    - Les *Services* sont instanciés à leur 1ère utilisation et sont conservés jusqu'à la fin de la session
    - Cependant les *Components* eux sont détruits dès qu'ils ne sont plus affichés, et de nouveau instanciés lorsqu'on y accède de nouveau
    - Si on change d'URL mais qu'il s'agit toujours du même *Component*, on conserve l'instance courante
    - Ainsi, lorsqu'on passait d'un document à l'autre, il arrivait que les services n'arrivent plus à communiquer entre eux
      - Certains streams étaient coupés à la destruction de *DocComponent*
    - Ou qu'au contraire les services continuent d'envoyer des données correspondant à un autre document
      - Notamment lorsqu'on revenait à la page de gestion des documents
    - Destruction du *WebChannel* lors de la destruction de *DocComponent*
    - Destruction du *WebChannel* précédent et génération d'un nouveau lors du passage d'un document à un autre
*** Planned
**** DONE MUTE : Ajouter la gestion des documents stockées en local
- Ajouter une page listant les documents stockées en local
- Elle devrait permettre d'accéder à ces documents et de les supprimer
** Semaine du <2017-01-16 lun.> au <2017-01-20 ven.>
*** Done
- MUTE : Refactoring du couplage entre les services
  - Mapping des entrées/sorties des services dans le *Module* qui les fournit
- MUTE : Rendre générique l'utilisation des *StorageServices* par *DocService*
  - Puisque les services fonctionnent dorénavant par le biais d'entrées/sorties, cette tâche n'est plus pertinente
- MUTE : Ajouter le mécanisme de join propre
  - Ajout de *SyncService*
    - Ajoute à chaque opération émise un couple /id/ et /clock/
    - Maintient en parallèle un vecteur d'état indiquant pour chaque pair la /clock/ correspondant à sa plus récente opération reçue
    - Lorsqu'on rejoint un document, émet ce vecteur d'état à un pair
    - Celui-ci compare notre vecteur d'état avec le sien pour déterminer quelles sont les opérations que nous avons manquées
  - Ajout de *SyncMessageService*
    - Il s'agit du composant chargé de l'envoi et de la réception des messages de synchronisation
    - Observe les sorties de *SyncService*, les encode avec /Protobuf/ et utilise *NetworkService* pour les transmettre aux autres pairs
    - Observe *NetworkService* pour récupérer les messages lui étant destinés et instancie à partir de ces données les objets attendus par *SyncService*
  - Ajout de *SyncStorageService*
    - Il s'agit du composant chargé d'enregistrer l'état de *SyncService* pour le réutiliser à la prochaine session
    - Observe les sorties de *SyncService* pour récupérer son état et le stocker
    - Observe *NetworkService* pour détecter le document courant, récupérer l'état correspondant et le transmettre à *SyncService*
  - Ajout du mapping de ces services dans *DocModule*
*** Planned
**** DONE MUTE : Refactoring du couplage entre les services
- Actuellement, les services sont couplés
  - On injecte dans le constructeur d'un service des instances des autres services dont il dépend
- Ainsi, ajouter un nouveau composant telle que *SyncService* implique de modifier les services qui vont interagir avec lui
- Refactorer les services pour qu'ils exposent leurs entrées et sorties sous forme de streams
- Mapper les entrées/sorties des services dans un composant d'/orchestration/
**** DONE MUTE : Ajouter le mécanisme de join propre
**** CANCELLED MUTE : Rendre générique l'utilisation des *StorageServices* par *DocService*
- Actuellement, l'utilisation de *BotStorageService* et *LocalStorageService* est implémentée en dur dans le code de MUTE
- De même, leur comportement est différent
  - Le bot de stockage se comporte comme un utilisateur
  - Alors que *LocalStorageService* fonctionne par le biais d'appels à une API
- Uniformiser leur utilisation par *DocService*
** Semaine du <2017-01-23 lun.> au <2017-01-27 ven.>
*** Done
- MUTE : Ajouter la seconde partie du mécanisme de synchronisation
  - Ajout de *Interval* qui représente les opérations qu'il nous manque d'un pair
    - /id/ identifie le pair
    - /begin/ et /end/ délimitent l'interval des /clocks/ qu'il nous manque
  - Modification du message *REPLYSYNC* pour qu'il comporte aussi un tableau d'*Intervals*
  - Génération de ce tableau lors du traitement du message *QUERYSYNC* par *SyncService*
- MUTE : Refactorer la liste des documents
  - Besoin de mettre en place un service intermédiaire *DocsStorage*
  - Ce service devrait
    - Récupérer les listes de documents provenant des différents services de stockage
    - Fusionner les listes de documents pour ne conserver qu'une seule occurrence par document
*** Planned
**** DONE MUTE : Ajouter la seconde partie du mécanisme de synchronisation
- Actuellement, lorsqu'on se connecte, on envoie son vecteur d'état à un pair
- Celui-ci détecte les opérations qu'il possède mais qu'il nous manque à partir de ce vecteur et du sien
- Il nous envoie ces opérations
- Il peut aussi détecter les opérations que l'on possède mais qu'il lui manque à partir de ces mêmes informations
- Ajouter cette seconde passe
** Semaines du <2017-01-30 lun.> au <2017-02-17 ven.>
*** Done
- MUTE : Extraire la logique interne de MUTE dans une librairie /mute-core/
  - Librairie disponible ici: https://github.com/coast-team/mute-core
  - Comporte *CollaboratorsService*, *DocService*, *SyncService* et *SyncMessageService*
  - Ajout de l'interface *MessageEmitter* permettant de spécifier le protocole et d'exposer
    - Les messages à broadcaster
    - Les messages à envoyer à un pair particulier
    - Les messages à envoyer à un seul pair, mais choisi aléatoirement
- MUTE : Corriger le déclenchement du message /QuerySync/
  - Ajout d'un setter /setJoinAndStateSources(joinSource, stateSource?)/
    - S'agit de la fusion des setters /set joinSource/ et /set storedStateSource/
  - Le traitement des 2 sources étant lié, il est nécessaire de lier leur affectation
  - /stateSource/ est un paramètre optionnel
  - C'est sa présence ou non qui permet de définir le comportement à adopter
- MUTE : Refactorer *EditorComponent* pour gérer correctement les tableaux de *TextOperations*
  - La méthode /CodeMirror.Editor.operation(fn: () => void)/ est employée ici
  - Consiste à exécuter un appel de la méthode passée en paramètre
  - Elle permet de modifier le contenu de l'éditeur *CodeMirror* sans que celui-ci ne déclenche de rafraîchissements
  - Ceci permet donc d'effectuer un grand nombre d'opérations avant d'afficher uniquement l'état final
  - Amélioration des performances de l'application
    - Initialisation plus rapide (de quelques secondes à 1 seule) de l'éditeur lors de la synchronisation via un pair ou le système de stockage avec 100+ opérations
- MUTE : Ajouter la suppression d'un ou plusieurs documents depuis la liste des docs
  - Ajout de /delete (name: string): Promise<void>/ et /deleteAll (): Promise<void>/ à *AbstractStorageService*
  - Modification de *DocsComponent* pour utiliser ces fonctions
  - Utilisation de *MdSnackBar* pour afficher le message d'erreur si une se produit
    - Besoin de respecter un délai (~500ms) entre chaque message sous peine de faire planter l'UI
*** Planned
**** DONE MUTE : Extraire la logique interne de MUTE dans une librairie /mute-core/
- Actuellement, la logique de l'application se trouve directement dans *MUTE*
- Ceci pose des problèmes de duplication du code lorsqu'il s'agit d'écrire
  - un bot
  - une version /React/ de *MUTE*
- Extraire la logique interne et la déplacer dans une librairie /mute-core/ permettrait une meilleure réusabilité du code
**** DONE MUTE : Adapter /mute/ pour utiliser /mute-core/
- Une fois /mute-core/ implémentée, il est nécessaire de refactorer /mute/ pour
  - Supprimer les services obsolètes/dupliqués dans /mute-core/
  - Instancier *MuteCore* et effectuer le mapping de ses entrées/services avec les composants de /mute/
  - Gérer la destruction de l'instance de *MuteCore*
**** DONE MUTE : Refactorer *CursorsService* en *CursorsDirective*
- Un *Service* Angular ne devrait pas affecter l'interface graphique selon moi
- Cependant, *CursorsService* le fait
- L'utilisation d'un *Component* ou d'une *Directive* est plus indiquée dans ce cas de figure
- Ici, il s'agirait plutôt d'une *Directive*
  - On souhaite ajouter un comportement à un *Component* existant, l'éditeur
- Ceci permettra en plus
  - De passer des paramètres à la directive via les /@Input()/
  - De profiter des lifehooks proposés par Angular
**** DONE MUTE : Remplacer les couples *Observable/Observers* par des *Subjects*
- Jugeant que *AsyncSubject*, *BehaviorSubject* et *ReplaySubject* ne correspondaient pas à ce que je voulais faire, j'ai utilisé à la place des couples *Observable/Observers*
  - Génère et expose un *Observable*
  - Maintient la liste des *Observers* qui ont /subscribe()/ à l'*Observable*
- Ceci complexifie inutilement le code
  - Lors de la génération de l'*Observable*, on retrouve généralement le code suivant
    #+BEGIN_SRC
    this.observable = Observable.create((observer) => {
      // Ajout du nouvel observer à la liste des observers lors d'un subscribe() 
      this.observers.push(observer)
    })
    #+END_SRC
  - Puis, lors de l'émission d'une nouvelle valeur
    #+BEGIN_SRC
    this.observers.forEach((observer) => {
      observer.next(valeur)
    })
    #+END_SRC
- Philippe vient de m'apprendre qu'il existe le type *Subject* qui implémente déjà ce comportement
- Utiliser *Subject* à la place de ces couples
**** DONE MUTE : Remplacer les /Observable.map()/ par des *Subscriptions* + *Subjects*
- Actuellement, certains *Observables* exposés par des composants de l'application sont générés en effectuant un mapping sur un flux en entrée
- Cependant ceci pose plusieurs problèmes
  - Le composant ne possède pas le moindre contrôle sur l'*Observable* généré par le mapping
    - Il se contente de transformer les valeurs qu'il reçoit et les retransmettre
    - Il ne peut donc pas émettre d'évènement /complete/ si besoin, notamment lors de sa destruction
  - Le flux de sortie n'est pas généré tant que le flux d'entrée n'a pas été passé au composant
    - Ainsi, essayer de s'abonner au flux de sortie avant d'avoir fourni le flux d'entrée génèrera une erreur
- Ce comportement me paraît donc /error-prone/
- Il serait préférable d'instancier en interne des *Subjects* et de les exposer sous forme d'*Observables*
- Le composant doit donc s'abonner aux flux d'entrées, effectuer les opérations de transformation et émettre les nouvelles valeurs via les *Subjects*
**** DONE MUTE : Corriger le déclenchement du message /QuerySync/
- La condition de déclenchement du message /QuerySync/ est un peu particulière
  #+BEGIN_SRC
  if storageService
    wait(JoinEvent, IsReadyEvent) // où IsReadyEvent indique quand on a fini d'initialiser le document à partir de la version stockée dans le système de stockage 
  else
     wait(JoinEvent)
  #+END_SRC
- Actuellement, le code gérant ce déclenchement est brouillon
- Améliorer ça
**** DONE MUTE : Coder en dur le nom des services lorsqu'ils émettent des messages
- Un message est composé de contenu mais aussi d'un champ /service/
- Ce champ permet aux services, lorsqu'ils reçoivent un message, de filtrer uniquement les messages les concernant
- Actuellement, lorsqu'un service émet un message, il renseigne ce champ en utilisant /this.constructor.name/ afin que ce nom soit unique
- Cependant, lorsqu'on build l'application pour le mode production, une minification du code est effectuée
- Et il semblerait que suite à cette minification, plusieurs services se retrouvent avec un constructeur de même nom
- Les services essaient donc de parser et de traiter des messages qui ne leurs sont pas destinés
- Remplacer les /this.constructor.name/ par des constantes
**** DONE MUTE : Refactorer /mute-core/ pour pouvoir traiter des tableaux de *LogootSOperations*
- Comme on émet les *LogootSOperations* une par une, /mute-core/ est designé pour les recevoir une par une
- Ainsi, lorsqu'une *RichLogootSOperation* est reçue
  - Elle est transformée en *LogootSoperation* par *SyncService*
  - Elle est appliquée au modèle par *DocService*
  - Puis *DocService* émet la *TextOperation* correspondante
- Cependant, nous pouvons recevoir plusieurs *RichLogootSOperations* d'un coup maintenant
  - Lors de l'initialisation en utilisant le système de stockage
  - Lors de la synchronisation avec un autre pair
- Nous envoyons donc une multitude de messages inutilement
- Ces messages peuvent eux-mêmes déclencher des rafraichissements de l'interface
**** DONE MUTE : Refactorer *EditorComponent* pour gérer correctement les tableaux de *TextOperations*
- Maintenant que *DocService* émet plusieurs *TextOperations* en un seul message, il est nécessaire d'adapter *EditorComponent*
- Améliorer les performances de l'application en désactivant le rafraichissement de *CodeMirror* dès que son contenu est modifié
  - Rafraichir *CodeMirror* qu'une fois qu'on a fini d'appliquer l'ensemble des *TextOperations*
**** DONE MUTE : Ajouter la suppression d'un ou plusieurs documents depuis la liste des docs
- Maintenant que nous proposons une liste des documents, il est nécessaire de pouvoir la gérer
- Il faut donc pouvoir supprimer un ou plusieurs documents
** Semaine du <2017-02-20 lun.> au <2017-02-24 ven.>
*** Done
- CRDT : Lire *CRDT notes*
  - Pessimistic Replication
    - Système de lock
    - Lorsqu'un client essaie d'accéder ou de modifier la donnée repliquée, un système de synchronisation empêche les réplicas de diverger
    - Semble lourd (quid de la disponibilité ?) mais semble utilisable dans certains cas
      #+BEGIN_QUOTE
      But, in local area networks, it can be acceptable because the latency to contact another replica is low.
      #+END_QUOTE
  - Active Replication
    - Lorsqu'un client essaie de modifier la donnée répliquée, l'ensemble des replicas est modifié au cours de la transaction
      - Ne peut pas avoir une divergence des replicas
*** Planned
** Semaine du <2017-02-27 lun.> au <2017-03-03 ven.>
*** Done
- TVPaint
  - Récupérer la liste des process
    - GET http://localhost:8728/bonita/API/bpm/process?s
    - Paramètres
      - /s/: le champ avec lequel on souhaite filtrer
    - Exemple:
      - GET http://localhost:8728/bonita/API/bpm/process?s=Demo Movie Management
    - Réponse:
      #+BEGIN_SRC
[
  {
    "displayDescription": "",
    "deploymentDate": "2017-02-27 16:55:39.076",
    "displayName": "Demo Movie Management",
    "name": "Demo Movie Management",
    "description": "",
    "deployedBy": "4",
    "id": "5736144163858952046",
    "activationState": "ENABLED",
    "version": "1.0",
    "configurationState": "RESOLVED",
    "last_update_date": "2017-02-27 16:55:39.208",
    "actorinitiatorid": "502"
  },
  {
    "displayDescription": "",
    "deploymentDate": "2017-02-20 15:37:44.819",
    "displayName": "Movie Management",
    "name": "Movie Management",
    "description": "",
    "deployedBy": "4",
    "id": "9107737410621326053",
    "activationState": "ENABLED",
    "version": "1.0",
    "configurationState": "RESOLVED",
    "last_update_date": "2017-02-20 15:37:45.103",
    "actorinitiatorid": "401"
  }
]
      #+END_SRC
  - Récupérer le contrat d'instantiation d'un process
    - GET http://localhost:8728/bonita/API/bpm/process/:processId/contract
    - Exemple:
      - GET http://localhost:8728/bonita/API/bpm/process/5736144163858952046/contract
    - Réponse:
      #+BEGIN_SRC
{
  "inputs": [],
  "constraints": []
}
      #+END_SRC
  - Instancier un process
    - POST http://localhost:8728/bonita/API/bpm/process/:processId/instantiation
    - Exemple:
      - POST http://localhost:8728/bonita/API/bpm/process/5736144163858952046/instantiation
    - Réponse:
      #+BEGIN_SRC
{
  "caseId": 5004
}
      #+END_SRC
- MUTE : Modifier *MuteCore* pour qu'il n'attende plus un *JoinEvent* pour démarrer
  - Ajout de /initSubject/ dans *MuteCore* et de la méthode /init(key: string)/ pour signaler que le modèle est initialisé
  - Modification de *DocService* pour dépendre de *InitEvent* et non plus *JoinEvent*
  - Modification de *SyncService* pour récupérer l'id de l'utilisateur lors de la construction de l'objet
  - Modification de *NetworkService* pour déclencher le join après l'initialisation
  - Modification de *StorageService* pour récupérer l'état après l'initialisation
  - Modification de *DocComponent*
    - Génération de l'id de l'utilisateur
      - On ne dispose à ce moment d'aucune information sur les autres pairs
      - Il faut donc générer un identifiant (*int32*) et espérer qu'il soit unique
      - /Math.random()/ permet de le faire
      - Mais utiliser un générateur de nombres aléatoires à sécurité cryptographique permet de s'assurer un comportement plus aléatoire
      - [[https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues][getRandomValues()]] permet de faire ça dans le browser
*** Planned
**** DONE MUTE : Modifier *MuteCore* pour qu'il n'attende plus un *JoinEvent* pour démarrer
- Actuellement, *JoinEvent* est l'évènement initial qui permet au modèle
  - De s'instancier
  - De récupérer l'état stocké en local
  - De se synchroniser avec un pair
- Cet évènement est seulement déclenché lorsqu'on rejoint le réseau
- Si un problème empêche l'utilisateur de rejoindre le réseau, alors l'éditeur est inutilisable
- Alors que rien n'empêche de travailler en mode déconnecté pour le moment et de tenter de se reconnecter plus tard
- Modifier la logique interne de *MuteCore* pour
  - Ajouter un *InitEvent* indiquant au modèle
    - De s'instancier
    - De récupérer l'état stocké en local
  - *JoinEvent* ne permettra que de déclencher une synchronisation
** Semaine du <2017-03-06 lun.> au <2017-03-10 ven.>
*** Done
- MUTE : Refactorer la liste des documents
  - Philippe s'en est chargé
- MUTE : Ajouter la gestion du titre du document
  - Un simple *LWW-Register* suffit
  - La seule difficulté concerne la génération du timestamp utilisé pour ordonner les titres
  - Une horloge de Lamport ne semble pas suffire
    - Permet d'assurer que pour des opérations /a/ et /b/ et une fonction /C(x)/ retournant le timestamp d'une opération /x/, alors /a -> b => C(a) < C(b)/
    - Mais ne permet pas de s'assurer que /C(a) < C(b) => a -> b/
    - En effet /C(a) < C(b)/ peut aussi indiquer que les opérations sont en concurrence
  - Besoin d'ajouter un élément pour créer un ordre total
    - Dans le cas d'une égalité entre les horloges, l'identifiant de l'utilisateur peut être utilisé pour ordonner les timestamps
    - Exemple pour deux timestamps /<ts, id>/ et /<ts', id'>/ :
      #+BEGIN_SRC
      if (ts > ts') return <ts, id>
      if (ts' > ts) return <ts', id'>
      if (id > id') return <ts, id>
      return <ts', id'>
      #+END_SRC
- Thèse : Discussion avec Claudia
  - Discussion autour du sujet de thèse
  - Continuer les travaux autour du modèle de confiance
  - Amélioration de l'expérience basée sur le trust game
    - Ajout d'un mécanisme de réputation
      - La confiance est
      - La réputation, elle, est établie sur un groupe d'utilisateurs
    - Comparaison du comportement des utilisateurs par rapport à la confiance et/ou à la réputation
  - Application du modèle de confiance à l'édition collaborative
    - Evaluation de la qualité des contributions d'un utilisateur
    - Déterminer les compromis d'une collaboration
    - Prédiction des actions d'un utilisateur en fonction
    - Gestion des droits d'accès par rapport au score de confiance
- Thèse : Discussion avec Gérald
  - Problème de renaming pas adapté à l'équipe
    - Pas exactement le domaine de compétence et le type de problème habituellement traité
  - Idée d'interactions entre un système externe et un CRDT
    - Un document et son modèle CRDT correspondant pourraient être stockés dans git
    - Un utilisateur, avec une application externe, pourrait vouloir modifier le document
    - Comment détecter les changements et mettre à jour son modèle CRDT
    - Comment transmettre ces modifications à l'éditeur
  - Faire le lien avec les cahiers scientifiques
    - De plus en plus de cahiers scientifiques sont rédigés pour des raisons de reproductibilité
      - Plusieurs formats: IPython, ORG-mode
    - Pourraient être rédigés de façon collaborative
    - Embarque des morceaux de code à exécuter
    - Où exécuter les tâches ?
      - Peut vouloir déléguer l'exécution des tâches si elles sont lourdes
      - Retrouve la notion de bot ?
    - Besoin de répliquer les données de l'expérience si délégation de l'exécution
- MUTE : Débugger la liste des documents
  - [ ] Réinitialiser *NavComponent* lors de son affichage
    - Dans ce cas, sélectionner un dossier déclencherait une mise à jour de /activeFile/
  - [ ] Distinguer /activeDoc/ et /activeFolder/
    - *DocsComponent* a besoin de connaitre /activeFolder/ à son initialisation pour générer la liste des documents
    - *NavComponent* permet de mettre à jour /activeFolder/ lorsqu'un changement du dossier sélectionné est détecté
    - *DocComponent* peut mettre à jour /activeDoc/ à son initialisation et à sa destruction
    - *ToolbarComponent* a besoin de connaitre /activeFolder/ et /activeDoc/
      - Si /activeDoc/ est défini, alors affiche ses infos
      - Sinon, affiche les infos de /activeFolder/
      - Peut facilement être implémenté avec /combineLatest/ de *RxJS*
        #+BEGIN_SRC
        activeFolderSource
         .combineLatest(activeDocSource)
         .map(([folder: Folder, doc: Doc]) => {
           if (doc) {
             return doc
           }
           return folder
         })
         .subscribe((file: File) => {
           // Do something
         })
        #+END_SRC
- PIDR : Réflexion avec Quentin et Gérald
  - Lien entre l'automate qu'on souhaite obtenir et le fonctionnement interne d'une chaîne de Markov par exemple
  - La question était "Pourquoi ne pas effectuer les actions du bot directement plutôt que de générer un fichier ?"
    - Reproductibilité de l'expérience
    - Permet de découpler le modèle d'apprentissage et l'implémentation du comportement
    - Comme le fichier suit le formalisme d'une grammaire, peut facilement utiliser un parser pour implémenter le comportement
- PIDR : Réflexion avec Vinh et Le
  - Le résultat de l'analyseur de traces doit être une machine à états ou sa représentation
    - Sinon, de quoi pourrait-il s'agir ?
      - Une séquence d'actions ?
	- Dans ce cas, on aurait un ou plusieurs comportements fixés pour un groupe d'utilisateurs donné
	- Est-ce représentatif ?
	- Mais au moins, ça serait reproductible
  - Une chaîne de Markov a pour but de prédire la prochaine action en fonction de l'état actuel
    - L'état actuel doit contenir toutes les informations nécessaires pour faire le choix
  - Une chaîne de Markov ne correspondrait donc pas si ce que l'on cherche à obtenir est un automate
  - Conseillent de regarder plutôt du côté du /process mining/
    - Vinh recommande [[http://www.processmining.org/prom/start][Prom]]
    - Permettrait d'extraire une machine à états pondérée à partir de séquences d'actions
- MUTE : Débugger l'ouverture d'un nouveau document
  - Bug dû à l'enchainement des évènements
  - Actuellement, lorsque *EditorComponent* détecte un changement de l'instance *DocService*, il s'abonne à /onDocValue/ pour récupérer la nouvelle valeur
  - Lorsqu'une nouvelle valeur du document lui est fourni, il met à jour le contenu du document
  - Mais depuis la refonte pour utiliser /onInit/, /onDocValue/ est déclenché avant que *EditorComponent* se soit abonné
  - Attendre que *EditorComponent* soit initialisé pour appeler /muteCore.init()/ dans *DocComponent*
*** Planned
**** CANCELLED MUTE : Refactorer la liste des documents
- Actuellement, on affiche la liste de tous les objets contenus dans la BDD pour former la liste des documents
- Sauf que certains objets ne devraient pas en faire partie
  - Les données conservées pour chaque document pour *SyncService* par exemple
- De plus, on différencie les documents en fonction des systèmes de stockage où ils sont conservées
- Cela peut s'avérer perturbant pour les utilisateurs
- Unifier la liste des documents
**** DONE MUTE : Débugger la gestion des documents
- Depuis la mise à jour de la liste des documents, la sauvegarde en locale des documents n'est plus disponible
- On enregistre les meta-données du document
  - Titre
  - Clé
  - Stockages utilisés
- Mais plus son contenu
- Débugger ça
** Semaine du <2017-03-13 lun.> au <2017-03-17 ven.>
*** Done
*** Planned
**** TODO MUTE : Débugger l'ouverture d'un nouveau document
- Si on est sur *DocComponent* et qu'on ouvre un nouveau document, le contenu du document n'est pas remis à 0
- Résoudre ce bug
**** TODO TVPaint : Implémenter le prototype orchestrant TVPaint server et Bonita
- Devrait orchestrer les 2 serveurs pour jouer les tâches suivantes :
  - Créer un film
  - Associer des shots au film
    - Besoin potentiellement de créer les shots
  - Associer des clips au shot
    - Besoin potentiellement de créer les clips
**** TODO MUTE : Débugger la liste des documents
- Lorsqu'on souhaite re-afficher la liste des documents alors que nous étions sur la page d'un document, la liste ne se génère pas dans tous les cas
- La liste de *DocsComponent* est générée à partir de la valeur /activeFile/
  - S'il s'agit d'un *Folder*, récupère et affiche la liste de ses documents
  - Sinon ne fait rien
- La valeur de /activeFile/ est mise à jour à plusieurs endroits
  - Lorsque l'utilisateur sélectionne un nouveau dossier dans *NavComponent*
    - Dans ce cas, /activeFile/ prend pour valeur ce dossier
  - Lorsqu'on accède à un document
    - Alors /activeFile/ prend pour valeur ce document
- Cependant, comme *NavComponent* n'est jamais détruit, il se "souvient" du précédent dossier selectionné
- Ainsi, si on sélectionne le même, aucun changement n'est détecté
  - La valeur de /activeFile/ n'est donc pas mise à jour
- Ainsi, comme /activeFile/ correspond toujours au dernier document ouvert, *DocsComponent* ne génère pas de liste
- Corriger ce comportement
**** TODO MUTE : Ajouter la gestion du titre du document
- Le titre du document peut être l'objet de modifications concurrentes
- Il est donc nécessaire de s'assurer qu'il converge chez tous les utilisateurs
- Utiliser *LogootSplit* pour gérer le titre semble un peu /overkill/
- Un simple *LWW-Register* suffirait
- Voir pour lier le document et son titre
  - Le titre peut être amener à évoluer suite à des modifications du document
  - Lier l'état du document et l'état du titre?
**** TODO MUTE : Améliorer le pipe /slice/ d'Angular pour les *Strings*
- Angular propose un pipe /slice/ permettant de limiter le nombre de caractères que nous souhaitons afficher d'une *String*
- Cependant, rien n'indique dans le résultat si la chaîne de caractères a effectivement été tronquée ou non
- Créer un pipe /sliceString/ ajoutant '...' au résultat si la chaîne a été coupée
**** TODO CRDT : Lire *CRDT notes*
- Disponible ici: https://github.com/pfrazee/crdt_notes
- Regroupe des notes de lectures sur plusieurs articles concernant les CRDT
**** TODO CRDT : Lire *A Conflict-Free Replicated JSON Datatype*
- Disponible ici: https://arxiv.org/pdf/1608.03960.pdf
**** TODO TVPaint : Développer la tâche compositing
- La tâche /compositing/ est une activité complexe
- La décomposer en plusieurs sous-tâches
  - Revoir les posts du forum qui y sont dédiés
**** TODO TVPaint : Définir un workflow correspondant au scénario de test
**** TODO PLM : Gérer les exercices n'ayant pas d'entité solution dans le langage de programmation par défaut
- Actuellement, on considère que l'ensemble des exercices possèdent une entité solution en Java
- Lors de leur instanciation à partir des sources, on essaie de calculer le(s) monde(s) objectif(s) à partir de cette entité solution
- Ajouter un mécanisme de fallback vers un autre langage si l'entité solution Java n'est pas trouvée
- Déclencher une erreur si aucune entité solution n'est trouvée
**** TODO PLM : Ajouter des tests d'intégration pour vérifier la sérialisation JSON
- Semblerait que la sérialisation JSON foire de temps en temps
  - Le JSON généré ne contient pas les opérations de la solution
- Implémenter des tests d'intégration
  - Vérifier si la sérialisation JSON existe
  - Vérifier si la sérialisation JSON peut être désérialiser correctement
  - Vérifier si l'instance obtenue possède des opérations solutions
  - Vérifier si les opérations solutions permettent bien d'atteindre l'état objectif ?
    - Je ne suis pas sûr qu'on puisse rejouer les opérations côté serveur actuellement
**** TODO PLM : Corriger l'exercice Polygon360
- L'exercice Polygon360 ne peut pas être résolu actuellement
- Lorsqu'on soumet le code de la correction, on n'arrive pas à atteindre le monde objectif
  #+BEGIN_SRC
  Le monde 'Polygon360' diffère: x1 diffère. (trouvé Line (x263.445 y135.028 / x264.177 y149.000 / black) au lieu de Line (x263.968 y154.996 / x264.177 y149.000 / black) ) 
  #+END_SRC
- L'erreur a été reportée ici : https://github.com/BuggleInc/webPLM/issues/130
**** TODO PLM : Trouver l'origine du crash de webPLM du <2016-10-12 mer.>
- L'application a de nouveau eu un crash le <2016-10-12 mer.>, de 17:54 jusqu'à 18h:26
- Il a fallu que je redémarre manuellement le container de webPLM
  - Pour une raison inconnue, il n'arrivait pas à redémarrer correctement
  - Suppression du container et déploiement d'un nouveau
- Voici les métriques récupérées par New Relic au moment du crash
  #+CAPTION: Informations sur les transactions web au moment du crash
  #+NAME:   fig:transactions.png
  [[file:img/crash-webplm-2016-10-12T17:54/transactions.png]]
  #+CAPTION: Informations sur les ressources utilisées par le serveur au moment du crash
  #+NAME:   fig:server.png
  [[file:img/crash-webplm-2016-10-12T17:54/server.png]]
  #+CAPTION: Informations sur les ressources utilisées par les différents processus au moment du crash
  #+NAME:   fig:processes.png
  file:img/crash-webplm-2016-10-12T17:54/processes.png
  #+CAPTION: Informations sur les ressources utilisées par les différents containers au moment du crash
  #+NAME:   fig:dockers.png
  [[file:img/crash-webplm-2016-10-12T17:54/dockers.png]]
- Les logs ne montrent aucune erreur expliquant le crash, seulement des requêtes d'exécution
  #+BEGIN_SRC
  2016-10-12 15:53:11 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8700 - Received a message
  2016-10-12 15:53:11 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8700 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo", "exerciseID":"recursion.logo.koch.Koch","code":"def snowFlake (levels:Int, length:Double) {\n    snowSide(levels, length);\n    right(120);\n    setColor( Color.blue);\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.orange);\n    snowSide(levels, length);\n    right(120);\n}\ndef snowSide(levels:Int, length:Double) {\n  if(levels==0){\n    return;\n  }else{\n    avance(length);\n    snowSide(levels-1,length/3);\n  }\n}"}}
  2016-10-12 15:53:11 +0000 [ERROR] from application in ForkJoinPool-3-worker-15 - PLMActor: executionActor ? StartExecution timeout
  2016-10-12 15:53:12 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - Received a message
  2016-10-12 15:53:12 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - {"cmd":"getExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.koch.HexaKoch"}}
  2016-10-12 15:53:15 +0000 [ERROR] from application in ForkJoinPool-3-worker-23 - PLMActor: executionActor ? StartExecution timeout
  2016-10-12 15:53:15 +0000 [ERROR] from application in ForkJoinPool-3-worker-29 - PLMActor: executionActor ? StartExecution timeout
  2016-10-12 15:53:17 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8651 - Received a message
  2016-10-12 15:53:17 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8651 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.spiral.Spiral","code":"var length : Int = 5\n\nbaisseCrayon()\ndef spiral(steps:Int, angle:Int, length:Int, increment:Int) {\n avance(length)\n  gauche(45)\n  spiral(0,8, length+3, increment+1)\n  \n}"}}
  2016-10-12 15:53:18 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8695 - Received a message
  2016-10-12 15:53:18 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8695 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.koch.Koch","code":"def snowFlake (levels:Int, length:Double) {\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.blue);\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.orange);\n    snowSide(levels, length);\n    right(120);\n}\n\ndef snowSide(levels:Int, length:Double) \n{\n  \n  if(length == 0)\n  {\n    return;\n  }\n  \n  else\n  {\n    avance(200);\n  }\n  \n}"}}
  2016-10-12 15:53:22 +0000 [ERROR] from application in ForkJoinPool-3-worker-5 - PLMActor: executionActor ? StartExecution timeout
  2016-10-12 15:53:23 +0000 [ERROR] from application in ForkJoinPool-3-worker-1 - PLMActor: executionActor ? StartExecution timeout
  2016-10-12 15:53:23 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8692 - Received a message
  2016-10-12 15:53:23 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8692 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.koch.SquareKoch","code":"void snowSquare (int levels, double length) {\n    squareSide(levels, length);\n    right(90);\n    setColor(Color.blue);\n    squareSide(levels, length);\n    right(90);\n    setColor(Color.orange);\n    squareSide(levels, length);\n    right(90);\n    setColor(Color.magenta);\n    squareSide(levels, length);\n    right(90);\n}\nvoid squareSide(int levels, double length) {\n  if(levels==0){avance(length);}\n  else{\n    squareSide(levels-1,length/2);\n    gauche(90);\n    squareSide(levels-1,length/2);\n    droite(90);\n    squareSide(levels-1,length/2);\n    droite(90);\n    squareSide(levels-1,length/2);\n    gauche(90);\n    squareSide(levels-1,length/2);\n  }\n}"}}
  2016-10-12 15:53:24 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8695 - Received a message
  2016-10-12 15:53:24 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8695 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.koch.PentaKoch","code":"void pentaKoch(int levels, double length) {\n  if(levels==0){\n    avance(length);\n  }\n  else{\n  pentaKoch(levels-1,length*0.4);\n    left(180-(360/5);\n    pentaKoch(levels-1,length*0.4);\n    right(360/5);\n    pentaKoch(levels-1,length*0.4);\n    right(360/5);\n    pentaKoch(levels-1,length*0.4);\n    right(360/5);\n    pentaKoch(levels-1,length*0.4);\n    left(180-(360/5);\n    pentaKoch(levels-1,length*0.4);\n  }\n}"}}
  2016-10-12 15:53:25 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - Received a message
  2016-10-12 15:53:25 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.koch.Koch","code":"def snowFlake (levels:Int, length:Double) {\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.blue);\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.orange);\n    snowSide(levels, length);\n    right(120);\n}\ndef snowSide(levels:Int, length:Double) {\n  avance(length)\n  snowSide(levels, length)\n  right(120)\n  snowSide(levels, length)\n  right(120)\n  snowSide(levels, length)\n}"}}
  2016-10-12 15:53:27 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - Received a message
  2016-10-12 15:53:27 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - {"cmd":"runExercise","args":{"lessonID":"recursion.logo","exerciseID":"recursion.logo.koch.Koch","code":"def snowFlake (levels:Int, length:Double) {\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.blue);\n    snowSide(levels, length);\n    right(120);\n    setColor(Color.orange);\n    snowSide(levels, length);\n    right(120);\n}\ndef snowSide(levels:Int, length:Double) {\n  if(levels==0){\n    return;\n  }else{\n    avance(length);\n    snowSide(levels-1,length/3);\n  }\n}"}}
  2016-10-12 15:53:30 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - Received a message
  2016-10-12 15:53:30 +0000 [DEBUG] from application in application-akka.actor.default-dispatcher-8689 - {"cmd":"stopExecution","args":{}}
  2016-10-12 16:27:11 +0000 [INFO] from application in application-akka.actor.default-dispatcher-2 - Execution Mode: TRIBUNAL
  #+END_SRC
**** TODO PLM : Ajouter [[plumbr.eu][plumbr]] à PLM
- S'agit d'une solution de monitoring pour JVM
- Voir comment elle s'intègre avec Docker et si conflit avec New Relic
* Glossaire
- Eventual convergence property
  #+BEGIN_QUOTE
  Copies of shared objects are identical at all sites if updates cease and all generated updates are propagated to all sites.
  #+END_QUOTE
- Precedence property
  #+BEGIN_QUOTE
  If one update /Oa/ causally precedes another update /Ob/, then,
  at each site, the execution of /Oa/ happens before the execution of /Ob/.
  #+END_QUOTE
- Intention-preservation
  #+BEGIN_QUOTE
  For any update /O/, the effect of executing /O/ at all sites is the same as the intention of /O/ when executed at the site that originated it,
  and the effect of executing /O/ does not change the effect of non concurrent operations.
  #+END_QUOTE
- Associativity
  #+BEGIN_QUOTE
  Associativity means that you can apply a function in any order:
    ~f(a,f(b,c)) = f(f(a,b),c)~
  #+END_QUOTE
- Commutativity
  #+BEGIN_QUOTE
  Commutativity means that a function's arguments are order-insensitive:
    ~f(a,b) = f(b,a))~
  #+END_QUOTE
- Idempotence
  #+BEGIN_QUOTE
  Idempotence means you can call a function on the same input any number of times and get the same result:
    ~f(f(x))=f(x) (e.g., max(42, max(42, 42)) = 42))~
  #+END_QUOTE
